// FootballScript Runtime Library
// /Users/daniel/dev/football-script/runtime/index.js

class FootballRuntime {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas ? canvas.getContext('2d') : null;
        this.players = new Map();
        this.ball = { x: 400, y: 250, vx: 0, vy: 0 };
        this.score = { home: 0, away: 0 };
        this.events = [];
        this.animations = [];
        this.soundEnabled = true;
        this.debugMode = false;
        this.fieldWidth = 800;
        this.fieldHeight = 500;

        // Chelsea-specific elements
        this.chelseaColors = {
            blue: '#034694',
            white: '#FFFFFF',
            darkBlue: '#023373',
            lightBlue: '#0a5eb0'
        };

        // Player positions template
        this.positions = {
            goalkeeper: { x: 50, y: 250 },
            defenders: [
                { x: 150, y: 100 },
                { x: 150, y: 200 },
                { x: 150, y: 300 },
                { x: 150, y: 400 }
            ],
            midfielders: [
                { x: 350, y: 150 },
                { x: 350, y: 250 },
                { x: 350, y: 350 }
            ],
            strikers: [
                { x: 550, y: 200 },
                { x: 550, y: 300 }
            ]
        };

        if (this.canvas) {
            this.setupCanvas();
            this.startGameLoop();
        }
    }

    setupCanvas() {
        if (this.canvas.width) {
            this.fieldWidth = this.canvas.width;
            this.fieldHeight = this.canvas.height;
        } else {
            this.canvas.width = this.fieldWidth;
            this.canvas.height = this.fieldHeight;
        }

        this.drawField();
    }

    drawField() {
        if (!this.ctx) return;

        const ctx = this.ctx;
        const w = this.fieldWidth;
        const h = this.fieldHeight;

        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, 0, h);
        gradient.addColorStop(0, '#2d8a2d');
        gradient.addColorStop(1, '#236b23');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        // Field pattern (stripes)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
        for (let i = 0; i < w; i += 40) {
            if (i % 80 === 0) {
                ctx.fillRect(i, 0, 40, h);
            }
        }

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;

        // Outer boundary
        ctx.strokeRect(20, 20, w - 40, h - 40);

        // Center line
        ctx.beginPath();
        ctx.moveTo(w / 2, 20);
        ctx.lineTo(w / 2, h - 20);
        ctx.stroke();

        // Center circle
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, 60, 0, Math.PI * 2);
        ctx.stroke();

        // Center spot
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(w / 2, h / 2, 4, 0, Math.PI * 2);
        ctx.fill();

        // Left goal
        ctx.strokeRect(20, h/2 - 60, 10, 120);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(20, h/2 - 60, 10, 120);

        // Right goal
        ctx.strokeRect(w - 30, h/2 - 60, 10, 120);
        ctx.fillRect(w - 30, h/2 - 60, 10, 120);

        // Penalty areas
        ctx.strokeRect(20, h/2 - 100, 80, 200);
        ctx.strokeRect(w - 100, h/2 - 100, 80, 200);

        // Goal areas
        ctx.strokeRect(20, h/2 - 40, 30, 80);
        ctx.strokeRect(w - 50, h/2 - 40, 30, 80);

        // Penalty spots
        ctx.beginPath();
        ctx.arc(80, h / 2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(w - 80, h / 2, 3, 0, Math.PI * 2);
        ctx.fill();

        // Corner arcs
        this.drawCornerArc(20, 20);
        this.drawCornerArc(w - 20, 20);
        this.drawCornerArc(20, h - 20);
        this.drawCornerArc(w - 20, h - 20);

        // Stamford Bridge text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('STAMFORD BRIDGE', w / 2, h / 2);
    }

    drawCornerArc(x, y) {
        const ctx = this.ctx;
        ctx.beginPath();

        if (x < 400 && y < 250) {
            ctx.arc(x, y, 15, 0, Math.PI / 2);
        } else if (x > 400 && y < 250) {
            ctx.arc(x, y, 15, Math.PI / 2, Math.PI);
        } else if (x < 400 && y > 250) {
            ctx.arc(x, y, 15, -Math.PI / 2, 0);
        } else {
            ctx.arc(x, y, 15, Math.PI, -Math.PI / 2);
        }

        ctx.stroke();
    }

    createPlayer(name, number) {
        const player = {
            name: name,
            number: number || Math.floor(Math.random() * 99) + 1,
            x: 100 + Math.random() * 600,
            y: 100 + Math.random() * 300,
            vx: 0,
            vy: 0,
            color: this.chelseaColors.blue,
            speed: 5,
            kickPower: 10,
            isHighlighted: false
        };

        this.players.set(name, player);
        this.logEvent(`âš½ ${name} (#${player.number}) enters the pitch!`, 'success');
        return player;
    }

    drawPlayers() {
        if (!this.ctx) return;

        this.players.forEach(player => {
            this.drawPlayer(player);
        });
    }

    drawPlayer(player) {
        const ctx = this.ctx;

        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(player.x, player.y + 18, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Highlight effect
        if (player.isHighlighted) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 22, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Player body
        const gradient = ctx.createRadialGradient(player.x - 5, player.y - 5, 0, player.x, player.y, 15);
        gradient.addColorStop(0, this.chelseaColors.lightBlue);
        gradient.addColorStop(1, player.color);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 15, 0, Math.PI * 2);
        ctx.fill();

        // White border
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Player number
        ctx.fillStyle = 'white';
        ctx.font = 'bold 11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(player.number, player.x, player.y);

        // Player name (if highlighted or debug mode)
        if (player.isHighlighted || this.debugMode) {
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.fillText(player.name, player.x, player.y - 25);
        }
    }

    drawBall() {
        if (!this.ctx) return;

        const ctx = this.ctx;

        // Ball shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(this.ball.x, this.ball.y + 10, 8, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ball
        const gradient = ctx.createRadialGradient(this.ball.x - 3, this.ball.y - 3, 0, this.ball.x, this.ball.y, 8);
        gradient.addColorStop(0, 'white');
        gradient.addColorStop(0.8, '#f0f0f0');
        gradient.addColorStop(1, '#d0d0d0');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.ball.x, this.ball.y, 8, 0, Math.PI * 2);
        ctx.fill();

        // Ball pattern
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Pentagon pattern (simplified)
        ctx.beginPath();
        ctx.moveTo(this.ball.x, this.ball.y - 5);
        ctx.lineTo(this.ball.x + 3, this.ball.y);
        ctx.lineTo(this.ball.x, this.ball.y + 3);
        ctx.lineTo(this.ball.x - 3, this.ball.y);
        ctx.closePath();
        ctx.stroke();
    }

    shoot(playerName) {
        const player = this.players.get(playerName);
        if (!player) {
            this.logEvent(`âŒ Player ${playerName} not found!`, 'error');
            return;
        }

        this.logEvent(`ðŸ’¥ ${playerName} takes a shot!`, 'info');

        // Calculate shot trajectory
        const goalX = this.fieldWidth - 30;
        const goalY = this.fieldHeight / 2 + (Math.random() - 0.5) * 100;

        this.animateShot(player, goalX, goalY, () => {
            if (Math.abs(goalY - this.fieldHeight / 2) < 60) {
                this.celebrate();
                this.score.home++;
                this.logEvent(`âš½âš½âš½ GOOOOOAL! Brilliant strike from ${playerName}!`, 'goal');
                this.updateScoreboard();
            } else {
                this.logEvent(`âŒ Wide! ${playerName}'s shot goes off target!`, 'error');
            }
        });
    }

    animateShot(player, targetX, targetY, callback) {
        const animation = {
            type: 'shot',
            startX: player.x,
            startY: player.y,
            targetX: targetX,
            targetY: targetY,
            progress: 0,
            speed: 0.03,
            callback: callback
        };

        this.animations.push(animation);
    }

    pass(fromName, toName) {
        const from = this.players.get(fromName);
        const to = this.players.get(toName);

        if (!from || !to) {
            this.logEvent(`âŒ Players not found for pass!`, 'error');
            return;
        }

        this.logEvent(`âš¡ ${fromName} passes to ${toName}`, 'info');

        const animation = {
            type: 'pass',
            startX: from.x,
            startY: from.y,
            targetX: to.x,
            targetY: to.y,
            progress: 0,
            speed: 0.04
        };

        this.animations.push(animation);
    }

    move(playerName, x, y) {
        const player = this.players.get(playerName);
        if (!player) {
            this.logEvent(`âŒ Player ${playerName} not found!`, 'error');
            return;
        }

        // Convert percentage coordinates to canvas coordinates
        const targetX = (x / 100) * this.fieldWidth;
        const targetY = (y / 100) * this.fieldHeight;

        const animation = {
            type: 'move',
            player: player,
            startX: player.x,
            startY: player.y,
            targetX: targetX,
            targetY: targetY,
            progress: 0,
            speed: 0.02
        };

        this.animations.push(animation);
        this.logEvent(`ðŸƒ ${playerName} moves to position`, 'info');
    }

    dribble(playerName) {
        const player = this.players.get(playerName);
        if (!player) return;

        // Move ball close to player
        this.ball.x = player.x + 10;
        this.ball.y = player.y;

        // Small random movement
        player.x += (Math.random() - 0.5) * 20;
        player.y += (Math.random() - 0.5) * 20;

        this.logEvent(`ðŸƒ ${playerName} dribbles with the ball`, 'info');
    }

    tackle(playerName) {
        const player = this.players.get(playerName);
        if (!player) return;

        this.logEvent(`ðŸ›¡ï¸ ${playerName} makes a tackle!`, 'info');

        // Check if ball is near
        const distance = Math.sqrt(
            Math.pow(this.ball.x - player.x, 2) +
            Math.pow(this.ball.y - player.y, 2)
        );

        if (distance < 50) {
            this.ball.x = player.x;
            this.ball.y = player.y;
            this.logEvent(`âœ… Successful tackle by ${playerName}!`, 'success');
        } else {
            this.logEvent(`âŒ ${playerName} missed the tackle!`, 'error');
        }
    }

    celebrate() {
        // Visual celebration
        if (this.ctx) {
            this.createCelebrationEffect();
        }

        // Sound effect (if implemented)
        if (this.soundEnabled) {
            this.playSound('goal');
        }
    }

    createCelebrationEffect() {
        const celebration = {
            type: 'celebration',
            x: this.fieldWidth / 2,
            y: this.fieldHeight / 2,
            progress: 0,
            particles: []
        };

        // Create particles
        for (let i = 0; i < 20; i++) {
            celebration.particles.push({
                x: celebration.x,
                y: celebration.y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                color: Math.random() > 0.5 ? this.chelseaColors.blue : 'gold'
            });
        }

        this.animations.push(celebration);
    }

    updateAnimations() {
        this.animations = this.animations.filter(anim => {
            anim.progress += anim.speed || 0.02;

            if (anim.type === 'shot' || anim.type === 'pass') {
                this.ball.x = anim.startX + (anim.targetX - anim.startX) * anim.progress;
                this.ball.y = anim.startY + (anim.targetY - anim.startY) * anim.progress;

                if (anim.progress >= 1) {
                    if (anim.callback) anim.callback();
                    return false;
                }
            } else if (anim.type === 'move') {
                anim.player.x = anim.startX + (anim.targetX - anim.startX) * anim.progress;
                anim.player.y = anim.startY + (anim.targetY - anim.startY) * anim.progress;

                if (anim.progress >= 1) {
                    return false;
                }
            } else if (anim.type === 'celebration') {
                // Update particles
                anim.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // Gravity
                });

                if (anim.progress >= 1) {
                    return false;
                }
            }

            return true;
        });
    }

    drawAnimations() {
        if (!this.ctx) return;

        this.animations.forEach(anim => {
            if (anim.type === 'celebration') {
                const ctx = this.ctx;
                anim.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw "GOAL!" text
                ctx.fillStyle = 'gold';
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = 1 - anim.progress;
                ctx.fillText('GOAL!', this.fieldWidth / 2, this.fieldHeight / 2);
                ctx.globalAlpha = 1;
            }
        });
    }

    render() {
        if (!this.ctx) return;

        this.drawField();
        this.drawPlayers();
        this.drawBall();
        this.drawAnimations();

        if (this.debugMode) {
            this.drawDebugInfo();
        }
    }

    update() {
        this.updateAnimations();
        this.updatePhysics();
    }

    updatePhysics() {
        // Ball physics
        this.ball.vx *= 0.98; // Friction
        this.ball.vy *= 0.98;

        this.ball.x += this.ball.vx;
        this.ball.y += this.ball.vy;

        // Boundary checking
        if (this.ball.x < 20) this.ball.x = 20;
        if (this.ball.x > this.fieldWidth - 20) this.ball.x = this.fieldWidth - 20;
        if (this.ball.y < 20) this.ball.y = 20;
        if (this.ball.y > this.fieldHeight - 20) this.ball.y = this.fieldHeight - 20;
    }

    startGameLoop() {
        const loop = () => {
            this.update();
            this.render();
            requestAnimationFrame(loop);
        };
        loop();
    }

    logEvent(message, type = 'info') {
        const event = {
            message: message,
            type: type,
            timestamp: Date.now()
        };

        this.events.push(event);

        // Emit to console if available
        if (typeof window !== 'undefined' && window.console) {
            const styles = {
                'success': 'color: #4CAF50; font-weight: bold;',
                'error': 'color: #f44336; font-weight: bold;',
                'info': 'color: #2196F3;',
                'goal': 'color: #FFD700; font-size: 16px; font-weight: bold;'
            };

            console.log(`%c${message}`, styles[type] || '');
        }
    }

    updateScoreboard() {
        if (typeof document !== 'undefined') {
            const scoreElement = document.getElementById('scoreboard');
            if (scoreElement) {
                scoreElement.textContent = `Chelsea ${this.score.home} - ${this.score.away} Opponent`;
            }
        }
    }

    drawDebugInfo() {
        const ctx = this.ctx;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(10, 10, 200, 100);

        ctx.fillStyle = 'white';
        ctx.font = '12px monospace';
        ctx.fillText(`Players: ${this.players.size}`, 20, 30);
        ctx.fillText(`Ball: (${Math.round(this.ball.x)}, ${Math.round(this.ball.y)})`, 20, 45);
        ctx.fillText(`Animations: ${this.animations.length}`, 20, 60);
        ctx.fillText(`Score: ${this.score.home} - ${this.score.away}`, 20, 75);
        ctx.fillText(`Events: ${this.events.length}`, 20, 90);
    }

    playSound(soundName) {
        // Placeholder for sound implementation
        // In a real implementation, this would play audio files
        console.log(`ðŸ”Š Playing sound: ${soundName}`);
    }

    reset() {
        this.players.clear();
        this.ball = { x: 400, y: 250, vx: 0, vy: 0 };
        this.score = { home: 0, away: 0 };
        this.events = [];
        this.animations = [];
        this.render();
    }

    // Educational helpers
    showGrid() {
        if (!this.ctx) return;

        const ctx = this.ctx;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;

        // Draw grid
        for (let x = 0; x <= 100; x += 10) {
            const px = (x / 100) * this.fieldWidth;
            ctx.beginPath();
            ctx.moveTo(px, 0);
            ctx.lineTo(px, this.fieldHeight);
            ctx.stroke();

            if (x % 20 === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px Arial';
                ctx.fillText(x, px, 15);
            }
        }

        for (let y = 0; y <= 100; y += 10) {
            const py = (y / 100) * this.fieldHeight;
            ctx.beginPath();
            ctx.moveTo(0, py);
            ctx.lineTo(this.fieldWidth, py);
            ctx.stroke();

            if (y % 20 === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px Arial';
                ctx.fillText(y, 5, py);
            }
        }
    }

    highlight(playerName) {
        const player = this.players.get(playerName);
        if (player) {
            player.isHighlighted = true;
            setTimeout(() => {
                player.isHighlighted = false;
            }, 2000);
        }
    }

    showStats(playerName) {
        const player = this.players.get(playerName);
        if (player) {
            this.logEvent(`ðŸ“Š ${playerName} Stats: Speed ${player.speed}, Power ${player.kickPower}`, 'info');
        }
    }
}

// Export for different environments
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FootballRuntime;
} else if (typeof window !== 'undefined') {
    window.FootballRuntime = FootballRuntime;
}
